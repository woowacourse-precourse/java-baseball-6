## UTECO 1주차 과제 - 숫자 야구 ⚾

---

### 목표

**JAVA 17을 활용한 숫자 야구 구현**

### 구현 방법 및 과정

1. HashMap을 이용한 구현 방법을 생각했다.

- 먼저 `정답 : 인덱스`의 맵 객체를 생성한다

- 이후 Map에 추가된 값의 수가 3이하일 경우, for 루프가 반복된다. 제공된 API를 통해 생성한 정수는 키로, 루프로 증가하는 인덱스는 값으로 하여 Map에 값을 추가한다.

  > 이 경우, 인덱스 값을 루프 내에서 증가시키는데, while 문으로 하는 게 좋을까?

- 입력값으로는 항상 3개의 숫자가 문자열로 공백없이 들어온다. 이를 위와 같이 for문으로 순회하며 한 자리씩 추출한다.

- **추출한 한 자리의 값이 map 객체에 key 값으로써 존재할 경우, 다시 해당 key 값으로 반환한 value와 순회중인 인덱스의 값이 같은지 확인한다.**

  - 값과 인덱스가 일치할 경우, 미리 생성한 score 변수에 3을 더하고, 값이 존재만 할 경우 1을 더한다.

- score 변수의 값을 3으로 나눈 나머지는 볼의 수가 되고, 3으로 나눈 몫은 스트라이크의 수가 된다.

- 이후 분기를 통해, score가 9인 경우는 정답, 0인 경우 낫씽, 둘 다 아닌 경우 몫과 나머지로 스트라이크와 볼을 파악한 뒤 출력할 문자열로 반환한다.

- 정답이 아닐 경우, 기존의 정답으로 다시 플레이할 수 있고, 정답이라면 새로운 정답 배열로 다시 시작할 수 있다.

- 입력값이 3자리의 중복되지 않은 숫자가 아닌 경우 IOEXCCEPTION을 반환한다.

```
리스트가 아닌 맵 형태으로 구현한 이유는, 시간복잡도를 낮추기 위함이었다. 만약 리스트로 구현할 경우, 정답 숫자 세 개를 모두 순회하며 비교해야 한다. 따라서 낫싱의 경우엔 한 번의 검증을 위해 9번의 연산이 필요하지만, 맵의 경우는 모든 경우에서 평균 3번의 연산으로 동작한다.

정말 미미한 수준이고, 숫자야구 규칙의 한계로, 아무리 숫자를 늘려도 리스트의 길이가 10을 넘길 수는 없다보니 리스트로 구현해도 문제는 큰 문제는 아닐 것 같다.
```

2. 정답 길이를 4나 5로 임의로 수정할 수 있게 만들기 위해, 길이 제한 변수를 활용하도록 수정하였다.

- 인스턴스 변수로 볼카운트의 수를 임의로 조정할 수 있도록 만들었다. 이를 위해 점수를 산정하는 방식까지 수정해야 했기에, 기존의 3이란 정수형이 들어갔던 부분이 인스턴스 변수를 참조하도록 바꿨다. 이젠 4자리의 조금 더 고난이도의 숫자야구를 즐길 수 있도록 만들었다.

```
이 과정에서 이전 로직의 문제점을 찾았다. 볼을 3으로 나누는 경우, 3볼일 때 1스트라이크를 반환한다. 따라서, 점수에 추가하는 경우 길이 + 1을 더하고, 스트라이크와 볼을 계산할 때도 해당 수로 나누어야 했다.

그러나 이 과정에서 public static 변수를 두 개 만들었는데, 변수명을 조금 더 고민해서 지어줘야 할 것 같다.
```
