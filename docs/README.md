# 기능 목록

## 구현할 기능들

- 게임 시작을 알리는 메시지 출력
- 게임 실행
  - 정답숫자를 생성함
  - 야구숫자를 입력받음
    - 야구숫자를 입력해달라는 메시지 출력
    - 야구숫자를 입력받음
  - 볼카운팅 결과를 생성
    - 야구숫자의 각 자릿수를 정답숫자와 비교, 취합
  - 볼카운팅 결과를 출력
  - 게임 종료 판단
    - 풀카운트면 게임 종료 절차
      - 풀카운트인지 확인
      - 게임 재시작/종료 메시지 출력
      - 게임 재시작/종료 입력받음
    - 풀카운트가 아니면, 계속 진행
    - 게임 재시작 시, '게임 시작' 단계부터 다시 실행
    - 게임 종료 시, 추가 동작 없이 동료
    - 계속 진행 시, '게임 시작 - 야구숫자를 입력받음' 단계부터 다시 반복

## 수행 리팩토링 목록

- 리터럴 상수 제거
- 경계 정리
  - 입력, 난수생성 기능이 외부 라이브러리를 직접 의존하고 있다.
  - 콘솔 출력 기능이 로직에 직접 포함되어 있다.
  - 입력, 난수생성, 출력 기능은 각각의 이유로 분리되는 편이 적절하다.
- 어플리케이션 실행과 로직을 분리하기
  - 현재 Application.java가 어플리케이션의 로직까지 가지고 있다.
  - 분리하는 것이 좋겠다고 판단했다. Application은 앱의 정상적인 실행과 실행 중 발생하여 최상위까지 올라오는 예외에 대한 책임만을 가지도록 하자.
  - 추가: 이 리팩토링은 불필요하다고 여겨져 결국 롤백되었다(참고: 8a409d)
- WinningNumbers와 BaseballNumbers를 테스트 가능하도록 수정하기.
  - '숫자 생성방법'을 객체로 추출하기.
    - '숫자 생성'을 행위로 가지고 있는 객체를 추출하자.
    - '야구숫자 생성'객체는 '야구숫자 생성방법'을 알고있을 의무가 있다.
    - '정답숫자 생성'객체는 '정답숫자 생성방법'을 알고있을 의무가 있다.
    - 각 '생성방법'은 교체 가능해야 하기 때문에(테스트 할 수 있어야 하기 때문에!) 동일 인터페이스의 구현체로 각기 만들어진다.
- Application의 예외 처리 로직을 BaseballGameTransaction으로 옮김
  - 어플리케이션의 실행 자체는 Application의 책임이고, 요청에 따라 로직이 잘 수행되거나 / 예외를 발생시켜 처리(여기서는 종료)되는 건 BaseballGameTransaction의 책임이 아닐까 생각되어 옮긴다.
- Input에서 다양한 타입의 인풋 지원하기
- BallCount 생성 시 유효성 검증 추가
- 가독성을 위한 메서드 추출: 유효성 검증 로직, 볼카운팅 로직 등
- early-return을 통한 임시변수 제거
- 과도한 상수 -> enum으로 교체
- 불필요한 객체 분리 상태를 다시 복구하고, 책임을 다시 적절하게 분배함.
  - 수정 전
    - Application은 프로그램의 시작만
    - BaseballGameTransaction에서 실행과 예외 처리의 책임과 로직 일부(게임 실행 및 재시작 로직)
    - BaseballGame에서 로직 일부(매 턴 수행)
  - 수정 후
    - Application이 프로그램의 시작점(entrypoint)이자 실행/예외처리를 책임짐.
    - BaseballGame은 게임 안내 및 게임시작/종료 로직
    - Turn은 매 턴 수행되는 맞추기 로직

## 참고

- 야구숫자:
  - 숫자여야 함
  - 세 자리여야 함
  - 각 자리가 중복되지 않아야 함
  - 양수여야 함
- 볼카운팅 과정:
  - 정답숫자와 포함은 되어있는데 자릿수가 일치하지 않으면 '볼'
  - 정답숫자와 포함이 되어있고 자릿수도 일치하면 '스트라이크'
  - 정답숫자에 포함이 되어있지 않으면 '낫싱'
- 풀카운트:
  - 볼카운팅(BallCount)이 3스트라이크인 경우를 말함

## 고민들 & 메모

### 2023-10-19 목
- '게임 종료 판단' 단계를 어떻게 구성하면 좋을지 모르겠다. 진행 중인지 재시작인지에 따라서 다시 시작되는 지점이 다른 것이 고민되는 지점.
- 테스트 코드는 언제 추가해야 하지?
- 레코드 이렇게 쓰는게 맞나? '볼카운팅'의 구현에 썼는데, 이럴때 쓰는게 적절한건가 모르겠다.
  - 레코드는 필드를 가질 수 없다는 특징을 알게 되었다.

### 2023-10-20 금
- 다른 코드들을 보면 Application에서 어떤 객체를 생성해서 실행하는 것으로 시작한다. 아래처럼.
```java
public class Application {
    public static void main(String[] args) {
        SomeGame game = new SomeGame();
        game.play();
    }
}
```
  - 꼭 이러한 패턴이어야 하는 이유는 뭘까? Application이라는 이름보다 '게임'이란 걸 수행한다는 걸 명확하게 하기 위함일 수도 있지만, 이 앱이 '어떤 게임에 관한 것'이라는 건 이미 패키지명 수준에서 충분히 설명되지 않나?
  - 지금 상황을 예로 들면, java-baseball 패키지의 Application은 java-baseball 앱이라는 걸 이미 직관적으로 표현하고 있는게 아닐까?
  - 하지만 로직 수행 책임과 어플리케이션의 동작 책임은 다르다.
- java.util.Objects#equals()를 여러번 사용하는 코드가 있어서, Objects를 static import 하려고 했는데 안된다. 이유가 뭘까?
- TODO 주석이 제대로 작성이 안된다. 인텔리제이 문제인 듯 하다. 대신할 만한 기능이 있나?...
- WinningNumbers와 BaseballNumbers를 테스트 가능하도록 수정하기.
  - 생성자 안에 생성하는 로직이 담겨 있어서 그렇다. 어떻게 분리할까?
  - 생성된 번호의 타입(List<Integer>)과 최대 길이 제한 상수(int MAX_SIZE)가 동일하게 있다.
    - 어쩌면 같은 개념의 객체 하나가 공통적으로 양 클래스에 내포되어있다는 신호 아닐까?
    - 같은 개념의 객체를 생성하는데, 두 가지 경우의 생성 방법을 활용할 수 있도록.
    - 산책하고 오니까 아이디어가 떠올랐다: 간단하게 보기 - MAX_SIZE와 numbers를 필드로 갖는 객체 뽑기. 근데! 해당 객체는 '숫자 생성방법'도 필드로 갖는다. '숫자 생성방법'은 인터페이스로, '정답숫자 생성방법', '야구숫자 생성방법'이라는 구체클래스가 속하게 된다.

### 2013-10-21 토
- WinningNumbers와 BaseballNumbers를 테스트 가능하도록 수정하기. (전날에 이어서...)
  - 아니다. 어쩌면 '숫자' 객체는 뽑힐 필요가 없다.
  - 뽑힌 '숫자' 객체는 공통된 속성과 행위를 가지기도 하지만, 결국 '정답숫자'냐 '야구숫자'냐에 따라서 다른 행위 책임을 가진다(볼카운팅, get 등...).
  - 그러면 결국 하나의 객체를 뽑아도, 쓰이는 코드 맥락에서 '정답숫자'냐 '야구숫자'냐에 따라서 다른 행위를 갖도록 결국 객체가 나뉜다.
  - 그러면 나눴다가 뽑았다가 나눴다가 뽑았다가... 무한 반복하게 될 뿐이다.
  - 다시 잘 생각해보자. '정답숫자'와 '야구숫자'는 다르다. 둘이 같은 것은 '숫자' 뿐이다. 같은 '숫자'인데, "숫자를 생성하는 방법"을 달리하고 싶을 뿐이다. 다르게 말해, 밖에서 넣어주고(변경하고) 싶은 것은 "숫자를 생성하는 방법"이다. 또 다르게 말해, 객체로 추출해야 하는 건 "숫자를 생성하는 방법"이다!
- 테스트 방식에 대해 고민이다. 생성될 값이 명확하지 않은 경우, 하지만 범위에 대해서 한정된 경우(예: 1~9 중 하나의 번호 생성)에 어떻게 테스트를 하면 좋을까?
  - 반복문을 충분히 많이 돌리는 식으로, 예외가 없을 거라고 만족해야 하나? 솔직히 이것밖엔 방법이 생각 안나는데, 마음에 안 드는 이유가 세 가지 있다.
    - 첫째. 그저 확률의 문제. 예외 케이스가 미처 등장하기 전에 반복문이 종료된 것일 수 있다.
    - 둘째. '충분히'는 얼만큼이 충분한가?
    - 셋째. 내가 원하는 만큼 '충분히' 돌리면, 반복문을 도느라 테스트 시간이 늘어난다. 한 개면 괜찮지만 이런 테스트가 엄청 많거나 한 로직을 공유하는 테스트가 다수면 테스트 시간이 쭉쭉 늘어나겠지...

### 2023-10-22 일
- 특정 타입의 인풋을 지원해보는건 어떨까? 
  - Java의 Scanner 클래스만 봐도 next, nextInt, nextLine 등으로 목적에 따라 사용할 수 있는 메서드를 제공한다.
  - 이걸 하려고 상상하다 보니 드는 생각인데... Input도 인터페이스화 하면 좋지 않을까? Input도 Console을 직접 사용하고 있기 때문에 테스트하기가 어려운건데 말이다. 음... 이건 나중에 다시 깊게 고민해보자.
- 인풋/아웃풋 테스트의 어려움
  - 콘솔 인풋/아웃풋을 테스트하려면 스트림을 원하는 인스턴스로 교체하는 수밖에 없다(Console 라이브러리, 구글링 참고).
  - 근데 이렇게까지 해서 테스트를 하는게 맞나 싶기도 하다. 인풋/아웃풋이 정상적으로 작동하는 것까지도 어플리케이션의 책임일까? 어쨌든 어플리케이션이 정상작동 하려면 확인해야 하는 부분이니까, 충분히 확인해둘만한 부분일까?
  - 일단 테스트를 위해서 중복되는 코드들(원하는 인스턴스로 교체하는 부분)이 발생했는데 이것은 추후 걷어내면 좋을 것 같다.
  - 이전 고민에서 언급한 것처럼 Input, Output을 인터페이스화 하고 테스트 할 때는 테스트 객체로 교체하는 식으로 하면, 그건 정상적인 테스트라고 할 수 있을까? 어렵다...

### 2023-10-23 월

- record의 compact constructor를 처음 써봤다. 다시는 까먹지 않을 것 같다.
- 테스트 케이스는 모든 경우의 수를 다 다루어야 할까?
- 아침에 일어나서 할 일: 리팩토링 - object 패키지의 객체들 중 의미파악이 어려운 코드들 개선할 것. 과도한 상수들은 enum으로 교체할 수 있는지 체크할 것.
- BaseballNumberGenerator#generate()에서 개선된 Input을 적용하다보니 느낀 점: 특수 목적의 인풋 메서드를 제공하니까, 메서드를 사용하는 쪽에서 '특수 목적'이 정상적으로 동작하는지 체크할 필요가 사라졌다. 당연한 말이지만, 이것이 좋게 느껴져서 메모를 남긴다. 그래서 현재는 특수목적(숫자 입력) 검증 로직 한 개가 사라지고 '야구숫자' 개념에 대한 유효성 검증만 세 개 남게 되었는데, '야구숫자 인풋'을 도입한다면 이 유효성 검증 세 개도 사라질 수 있겠다는 생각이 든다.
- `while (true)` 들을 제거할 방법이 없을까? 의미가 좀 더 잘 드러나게 하고 싶다. 예를 들어 `while (game.isPlaying())` 같은 식으로...
- 현재 BaseballGame은 아무런 상태도 가지지 않고 책임도 빈약하다. 책임 보다는 가독성을 위해 분리해놓은 느낌이다.
  - 리팩토링을 해볼까 하고 한 클래스로 코드를 몰아넣었는데 메서드만 간단히 옮겨서 정상 작동이 된다.
  - 책임을 생각하며 다시 나눠봐야겠다.