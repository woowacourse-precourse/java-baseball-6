# 구현할 기능 목록
- [x] 게임 시작 문구 출력하기
- [x] 상대방(컴퓨터)의 수 결정하기
	- [x] `camp.nextstep.edu.missionutils.Randoms`의 `pickNumberInRange()` 활용
	- [x] 반환된 값을 이용하여 상대방(컴퓨터)의 수 객체 생성
- [x] 사용자의 숫자 입력 받기
	- [x] `camp.nextstep.edu.missionutils.Console`의 `readLine()` 활용
	- [x] 사용자의 잘못된 입력 확인하기
		- [x] 3자리를 입력하였는가?
		- [x] 각각의 수는 1부터 9까지인가?
		- [x] 중복된 값을 입력하지 않았는가?
	- [x] 잘못된 입력이 확인되었을 시, `IllegalArgumentException`을 발생시키고 애플리케이션 종료시키기
- [x] 사용자의 입력에 대해 볼, 스트라이크 구분하기
	- [x] 자리와 숫자가 일치하는가?
	- [x] 해당 숫자가 다른 자리에 존재하는가?
- [x] 모든 숫자를 맞춘 경우 게임 종료 문구 출력하기
- [x] 게임 재시작 및 종료시키기
	- [x] 사용자의 숫자 입력 받기
	- [x] 재시작 및 종료 문구는 1, 2의 매직넘버를 사용하지 않기
# 고민
## View의 역할을 어디까지 가져갈 것인가?
초기 작성 시 View의 역할은 어디까지나 콘솔을 통해 사용자의 입출력을 처리하는 것이라 생각했습니다.
따라서 메서드는 출력 2개(줄바꿈이 있는가 여부), 입력 1개로 굉장히 간단하게 설계했습니다.
출력 메시지는 Controller 및 모델 객체 내부에 있으며 파라미터를 통해 전달하고 있습니다.
### 만약 콘솔이 아닌, 다른 View를 구성해야 한다면?
위의 구성이 확장 가능한 구조인지 생각해보았습니다.
터치 스크린이나 키패드를 이용한 입력인 경우, 스크린이나 프로그램을 통한 출력인 경우에도 해당 View의 역할을 그대로 가져갈 수 있을까요?
인터페이스를 통해 메서드를 정의한 후, 각각의 장치에 대한 클래스를 생성하고 확장시키는 구조를 가정하였습니다.
콘솔처럼 단순 메시지를 입력받는 형태가 아닌, 터치스크린을 통해 값을 전달받는 형태라면 지금과 같은 메서드들로는 해결되지 않을 것입니다. 숫자값을 입력받을 때에는 1부터 9까지의 값을, 게임 지속 여부에 대한 값을 입력받을 때에는 `예`, `아니오` 등의 값을 입력받는 게 더 자연스러울 테니까요.
그렇다면 사용자의 값 입력이 필요한 요구사항들은 각각의 메서드를 지니는 게 좋을 것 같습니다.
### 메시지 내용을 컨트롤러 및 모델이 지니고 있는 게 옳은가
사용자의 입력이 요구되는 부분이 아닌, 단순 알림(게임 시작 등)에 대해서도 생각해 보았습니다.
이 또한 콘솔을 통해서는 '콘솔 출력'으로 통일된 부분이나, 다른 방향으로 메시지를 줘야 할 경우도 있습니다.
게임 시작 시에는 위쪽의 안내메시지로, 종료 시에는 팝업으로 알려줄 수도 있으니까요. 각각의 폰트나 글씨크기가 다를 수도 있죠.
그렇다면, 각각의 알림마다 메서드를 작성하는 것이 추후 확장에는 유리할 수 있다는 결론이 나옵니다.
알림의 구현 방법 및 전달 메시지들이 구현체마다 변형될 수 있으니까요.
헌데 여기서 고민이 하나 더 생깁니다. 만약 전달해야 할 모든 메시지 내용이 같다고 했을 때, 해당 내용은 누가 지니고 있는 게 좋을까요?
컨트롤러나 모델이 지닌 게 아닌 View가 지니고 있는 게 좋은 것일까요?
### 메시지의 내용이 서비스 로직과 관련 있는 경우를 가정
이번 과제인 숫자 야구를 예시로 든다면 사용자의 입력을 1, 2로만 제한해야 할 경우가 있습니다.
이러한 값의 범위를 View가 직접적으로 들고 있는 것은 View의 책임 범위를 벗어난다 생각했습니다.
View의 메서드는 해당 범위값을 전달받아 메시지를 완성하여 보여주는 것이 옳은 방법이 아닐까 합니다.
즉, 해당 가정을 바탕으로 생각한다면 메시지 내용을 컨트롤러나 모델이 지니고 있는 것 또한 View나 컨트롤러, 모델의 책임 범위를 벗어난 형태로 판단되었으며, 서비스 로직과 관련한 값들은 파라미터로 전달받아 메시지를 완성시킬 수 있도록 하는 것이 좋은 구조라 생각되었습니다.

### 1, 2로 게임의 진행을 결정하는 상황에 대해
주어진 요구조건을 살펴보자면 게임이 끝난 후 1을 입력했을 시 새로운 게임을 시작, 2를 입력했을 시 게임을 종료합니다.
그러나 터치스크린으로 `예`, `아니오` 버튼을 띄우는 경우, 이는 내부적으로 1, 2의 값을 지정하는 것은 그렇게 좋은 방법이 아니라 생각합니다.
- 콘솔 입력 -> 콘솔 입력 어댑터를 통해 1은 `NEW_GAME`, 2는 `END_GAME`의 Enum으로 매핑, 반환
- 터치스크린 입력 -> `예` 버튼을 누를 시 `NEW_GAME`, `아니오` 버튼을 누를 시 `END_GAME`반환
위와 같은 구조를 지닐 때 더욱 좋은 코드가 나올 것이라 생각했습니다.
그러나 이 부분은 InputView가 바뀔 때 같이 영향을 받아 바뀌어야 하므로 비즈니스 로직이 아니라는 판단이 들었습니다. 따라서 싱글턴으로 만들어 각각의 InputView가 지니고 있게끔 하였으나, 단순 TF 반환으로도 해결되는 부분이었기에 boolean 반환 로직으로 작성하였습니다.

### 게임 결과를 toString()을 통해 전달하는 것이 옳은가
게임의 결과를 알려줄 때 단순히 GameResult 객체를 받아 toString()을 호출하는 것이 옳은 방법인지 생각하였습니다.
게임의 결과를 알려주는 방법은 View에 종속됩니다. 단순 콘솔 출력이더라도, toString() 메서드를 이용하는 것보다 사용자에게 보여줄 방법에 맞게 메시지를 생성하여 작성하는 게 옳다는 판단이 들어 리팩터링 하였습니다.

### 입력값을 그대로 전달하는 것은 옳은가
초기의 구조는 InputView를 통해 String 값을 그대로 특정 객체에 전달하는 형태였습니다.
그러다 보니 사용자의 숫자 입력과 게임 중단 결정에 대해 `readLine()`을 사용하는 메서드 하나만을 사용하였습니다.
위에서도 언급했듯, 어떠한 방법으로 View가 구성되냐에 따라 메서드는 달라져야 한다는 결론이 나왔으므로 두 개의 메서드로 분리하였습니다.
그러나 인터페이스를 구축하며, 여전히 같은 로직을 메서드명만 다르게 하여 구성했다는 생각이 들었습니다.
따라서 인터페이스 내 메서드만을 보고 어떠한 역할을 할 수 있는지 알 수 있게끔 `List<Integer>`를 반환하는 사용자의 숫자 입력을 받는 메서드와 `boolean`을 반환하는 사용자의 게임 중단 여부 메서드로 나눠 작성했습니다.
이는 View가 요구사항에 대한 올바른 데이터 타입을 반환하도록 하기 위함이고, 이 또한 View의 책임 범위라는 생각을 바탕으로 진행하였습니다. (무엇이 답인지는 아직 잘 모르겠습니다.)