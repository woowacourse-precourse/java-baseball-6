## 리팩터링 체크리스트

### 객체지향 생활체조 9원칙 +a

- [x] 한 메소드에 오직 ~~한 단계~~ 두 단계의 들여쓰기(indent)만 한다.
- [x] else 예약어를 쓰지 않는다.
- [ ] 모든 원시값과 문자열을 포장한다.
- [x] 한 줄에 점을 하나만 찍는다.
- [x] 줄여쓰지 않는다(축약 금지).
- [x] 모든 엔티티를 작게 유지한다.
- [x] 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
- [ ] 일급 컬렉션을 쓴다.
- [x] 게터/세터/프로퍼티를 쓰지 않는다.

### 추가 고려 사항

- 기능별로 메소드화하기
- 작은 단위에서 시작해서 점진적으로 확장하기

### 문제점 및 해결방법

- [x] ~~유효성 검사 로직: 반복적으로 사용되고, 코드가 지저분함~~
    - Validation 클래스로 분리
- [x] ~~야구 게임 로직: 가독성, indent 규칙 준수~~
    - 역할에 따라 세 개의 클래스로 분할하여 기능 분리
        - 상대방 역할의 Defender
        - 게임을 진행, 종료, 재시작해주는 Session
        - 이 둘을 처음 실행하며 가장 큰 틀을 잡아주는 Application
- [x] ~~static 수식자 사용 줄이기 -> 객체 지향적 설계~~
    - ~~현재 객체가 아닌 클래스를 통해 모든 기능 구현~~
    - ~~객체가 할 수 있는 일은 객체(인스턴스)를 통해 구현하기~~
    - 현재 한 번에 하나의 게임만 진행되므로(프로그램이 복잡하지 않으므로) 인스턴스화할 필요 없어보임
- [x] ~~각 클래스의 책임을 명확히 하기~~
    - ~~Defender 클래스가 현재 너무 많은 책임(정답 생성/관리, 스코어 계산/출력)~~
    - Defender 클래스와 ScoreKeeper 클래스로 분리
- [x] ~~Validation 클래스의 낮은 응집도~~
    - ~~현재 정답 입력값 검증과, 재시작 입력값 검증을 함께하고 있어 응집도가 비교적 낮음~~
    - ~~but 클래스를 분리하기에는 공통된 부분이 존재함~~
    - 서브클래스(상속) 사용으로 해결
    - ~~ValidationRestart 클래스에서 Validation과 관련없는 기능(Restart에 대한 true, false 리턴)을 하고있음~~
    - ValidationRestart 클래스에서 수행하던 재시작 여부 확인을 Session 클래스로 이동, ValidationRestart 클래스는 유효성 검사만을 수행
- [x] ~~매직 넘버~~
    - 매직 넘버는 명확한 설명 없이 직접 사용되는(하드코딩된) 리터럴
    - 프로그램 내에서 빈번히 사용되는 수(게임의 길이:3)를 별도의 상수 클래스에 포함하여 사용, 추후 재사용성 고려

### 추가 개선 필요한점

- [ ] 여전히 모호한 책임
    - Defender 클래스와 ScoreKeeper 클래스 간의 관계
    - 두 클래스가 수행하는 역할의 경계가 명확하지 않음
    - isBall과 isStrike 부분, 결과를 직접 받아 사용하고 있음(높은 결합도)
- [ ] 원시값 포장
    - 클래스의 인스턴스화 관련
    - Defender 클래스의 target, ScoreKeeper 클래스의 Score 등
- [ ] 일급 콜렉션
    - 콜렉션 인스턴스 변수가 하나만 존재
    - 원형이 존재하여 변경이 필요하면 새로운 콜렉션 반환
- [ ] 인스턴스 변수
    - 현재 모든 기능이 인스턴스가 아닌 클래스를 통해 구현됨
        - 너무 많은 static 메서드
    - 프로그램이 작아 문제되지 않지만 여러 기능을 동시에 수행할 땐 문제될 수 있음

## 정리

- 코드는 가독성과 재사용성을 고려하고 작성할 것
    - indent, 콤마, 축약금지, 매직넘버
- 통제할 수 있는 상황만 만들기
    - else, 원시값 포장, 게터/세터/프로퍼티, 인스턴스 변수
- 클래스 생성 원칙
    - 결합도는 낮게, 응집도는 높게
    - 책임과 기능에 따라
    - 가볍고 독립적일 것
